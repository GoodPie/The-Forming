#!/usr/bin/python
import pygame, sys, os, datetime, time, glob, math, random
from pygame.locals import *
 
#Screen Settings and variables
windowSize = window_width, window_height = 640, 640
half_width = window_width/2
half_height = window_height/2
block_size = block_width, block_height = 32, 32
depth = 0
flags = 32
 
#Mini map settings and variables
miniMap = map_width, map_height = 80, 80
half_map_width = map_width/2
half_map_height = map_height/2
 
 
#Ensuring the screen isn't to big for the amount of blocks
if window_width%block_width != 0 and window_height%block_height != 0:
    print "Screen is to big for the amount of blocks"
 
fps = 100 #Setting the maximum frames per second
 
#Colors (used mainly for minimap), [RRR, GGG, BBB]
#All colors should be added here instead of typing the color in a single piece
#of code
black = [000, 000, 000]
white = [255, 255, 255]
gray = [155, 155, 155]
red = [255, 000, 000]
green = [000, 255, 000]
blue = [000, 000, 255]
 
#loading all variables and what not to prepare the game#
def main():
    global screen, trees, obsticles,  grass, buildables, clock, level, image_cache, camera, background_entities, player_entities, player, map_entities
 
    #Initiating everything needed for the game
    pygame.init()
    screen = pygame.display.set_mode(windowSize)
    clock = pygame.time.Clock()
 
    image_cache = {}
    all_images = glob.glob("data/images/*.png")
    print "All Images Loaded!"
    for image in all_images:
        get_image(image, image_cache)
 
    #Creating Entity Groups
    background_entities = pygame.sprite.Group() #The background image entities
    player_entities = pygame.sprite.Group() #Holds NPC's and Player
    map_entities = pygame.sprite.Group() #Holds minimap entities
    obsticles = [] #Everything the player stops at...
    trees = [] #Gets all the trees
    grass = [] #Gets all the grass and sand and st00f
    buildables = [] #blocks that are buidable on
 
    player = Player(32, 32, image_cache)
    player_entities.add(player)
 
    #Initiating constants for the game
    current_level = currentLevelChecker()
    level = Checker(current_level)
 
    #This is the main process of the game (order of events that usually take place)
    start_menu()
    main_game_loop(level, obsticles, player)
 
 
#This is used to display and load the entire game#
def main_game_loop(level, obsticles, player):
    global total_level_height, total_level_width
 
    #defaulting everything
    #up = -, down = +, left = -, right = +#
    up = down = left = right = False
 
    total_level_width = len(level[0])*block_width
    total_level_height = len(level)*block_height
 
    camera = Camera(main_camera, total_level_width, total_level_height)
   
    #Setting up the background of the level
    back_x = back_y = 0
    for back_row in level:
        for back_col in back_row:
            Draw_Level( back_x, back_y, back_col, obsticles, background_entities, image_cache )
            back_x += 32
        back_y += 32
        back_x = 0
 
    #Used for the walking animation of the character
    walking = False
    mouse_clicked = False
    inv_image = get_image("data/images/Inventory.png", image_cache)
    inventory_show = False
    hit_block = False
    mouse_pos = pygame.mouse.get_pos()
    mouse = Mouse(mouse_pos)
    position_check = False
 
    while True:
        mouse_clicked = False
        clock.tick(fps)
        fps_current = float(clock.get_fps())
       
        pygame.display.set_caption("The Forming FPS:" + str(fps_current))
 
        for event in pygame.event.get():
            #Quit the game, for those who can't handle it#
            if event.type == QUIT:
                pygame.quit()
            #All keydown events (pushing down keys on keyboard...)#
            if event.type == KEYDOWN:
                if event.key == K_UP or event.key == K_w:
                    up = True
                    print "UP key was pressed"
                elif event.key == K_DOWN or event.key == K_s:
                    down = True
                elif event.key == K_LEFT or event.key == K_a:
                    left = True
                elif event.key == K_RIGHT or event.key == K_d:
                    right = True
                elif event.key == K_F1:
                    take_screen_shot(screen)
                elif event.key == K_F2:
                    pygame.display.toggle_fullscreen()
                elif event.key == K_q:
                    inventory_show = True
                elif event.key == K_p:
                    position_check = True
            #All keyup events (keys popup on keyboard...)#
            if event.type == KEYUP:
                if event.key == K_UP or event.key == K_w:
                    up = False
                elif event.key == K_DOWN or event.key == K_s:
                    down = False
                elif event.key == K_LEFT or event.key == K_a:
                    left = False
                elif event.key == K_RIGHT or event.key == K_d:
                    right = False
                elif event.key == K_p:
                    position_check = False
                elif event.key == K_q:
                    inventory_show = False
            #All mouse down events (when mouse is clicked)
            if event.type == MOUSEBUTTONDOWN:
                mouse_clicked = True
                hit_block = True
            if event.type == MOUSEBUTTONUP:
                mouse_clicked = False
                hit_block = False
 
        camera.update(mouse)
        camera.update(player)
 
        player.update(up, down, left, right, position_check, obsticles, trees,
                      total_level_width, total_level_height)
        walking = player.Walking_Animation(walking, up, down, left, right)
       
        for be in background_entities:
            screen.blit(be.image, camera.apply(be))
        for pe in player_entities:
            screen.blit(pe.image, camera.apply(pe))
 
        if inventory_show:
            screen.blit(inv_image,(0, 0))
 
        mouse_pos = pygame.mouse.get_pos()
        mouse.update(mouse_pos)
        mouse_offset = camera.apply(mouse)
        pos = mouse_pos[0] + mouse_offset.left , mouse_pos[1] + mouse_offset.top
        if hit_block:
            print "Mouse Screen Pos: ", mouse_pos
            print "Mouse Offset: ", mouse_offset
            print "Mouse Pos With Offset: ", pos
            print mouse.get_rect()
            replace_block(pos)
 
        pygame.display.flip()
 
#This is used to display the initial start menu#
def start_menu():
 
    start_game = False
 
    #Setting up images for start menu
    new_game = New_Game(half_width, half_height-50, image_cache)
    quit_game = Quit_Game(half_width, half_height + 10, image_cache)
   
    background = get_image("data/images/Menu_Background.png", image_cache)
    screen.blit(background, (0, 0))
    made_by = get_image("data/images/Credits.png", image_cache)
    screen.blit(made_by, (20, window_height-50))
 
    #Setting up button entities
    button_entities = pygame.sprite.Group()
    button_entities.add((new_game, quit_game))
 
    while not start_game:
        clock.tick(fps)
        fps_current = float(clock.get_fps())
       
        pygame.display.set_caption("The Forming FPS:" + str(fps_current))
        mouse_click = False
 
        for event in pygame.event.get():
            if event.type == QUIT:
                pygame.quit()
            if event.type == MOUSEBUTTONDOWN:
                mouse_click = True
            if event.type == KEYDOWN:
                if event.key == K_F1:
                    take_screen_shot(screen)
 
        screen.blit(background, (0, 0))
        screen.blit(made_by, (20, window_height-50))
       
        mouse_position = pygame.mouse.get_pos()
        new_game.update(mouse_position)
        quit_game.update(mouse_position, mouse_click)
        start_game = new_game.check_click(mouse_click, mouse_position)
 
        button_entities.draw(screen)
 
        pygame.display.flip()
 
#This passes all the entities to the game for drawing
def Draw_Level( x, y, column, obsticles, entities, image_cache ):
 
    #Grass#
    if column == "G":
        g = Grass(x, y, image_cache)
        entities.add(g)
        grass.append(g)
    #Plain Grass#
    elif column == "P":
        p = Plain_Grass(x,y, image_cache)
        entities.add(p)
        grass.append(p)
    #Grass with yellow flower#
    elif column == "F":
        f = Grass_Flower(x,y, image_cache)
        entities.add(f)
        grass.append(f)
    #Grass To Sand (50/50 split block) Direct#
    elif column == "Y":
        q = Grass_To_SandD(x,y, image_cache)
        entities.add(q)
        grass.append(q)
    #Tree#
    elif column == "T":
        t = Tree(x, y, image_cache)
        trees.append(t)
        entities.add(t)
    #Path#
    elif column == "O":
        o = Path(x, y, image_cache)
        entities.add(o)
        grass.append(o)
    #Sand#
    elif column == "S":
        s = Sand(x, y, image_cache)
        entities.add(s)
        grass.append(s)
    #Sand To Water (50/50 split block) Direct#
    elif column == "Q":
        q = Sand_To_Water(x, y, image_cache)
        entities.add(q)
    #Water#
    elif column == "W":
        w = Water(x, y, image_cache)
        obsticles.append(w)
        entities.add(w)
    #Dead Branch In Sand#
    elif column == "D":
        d = Sand_Dead(x, y, image_cache)
        entities.add(d)
        grass.append(d)
   
 
#Camera function
def main_camera(camera, target_rect):
    l, t, _, _ = target_rect
    _, _, w, h = camera
    l, t, _, _ = -l+half_width, -t+half_height, w, h
 
    l = min(0, l)
    l = max(-(camera.width-window_width), l)
    t = max(-(camera.height-window_height), t)
    t = min(0, t)
    return Rect(l, t, w, h)
 
def replace_block(mouse_pos):
 
 
    for g in grass:
        rect = g.get_rect()
        if rect.collidepoint(mouse_pos[0], mouse_pos[1]):
            print "A grass block has been clicked"
            new_image = Dug_Out(g.rect[0], g.rect[1], image_cache)
            grass.remove(g)
            buildables.append(new_image)
            background_entities.remove(g)
            background_entities.add(new_image)
            break
 
    for t in trees:
        rect = t.get_rect()
        if rect.collidepoint(mouse_pos[0], mouse_pos[1]):
            print "Tree has been clicked"
            new_image = Grass(t.rect[0], t.rect[1], image_cache)
            grass.append(new_image)
            trees.remove(t)
            background_entities.add(new_image)
            background_entities.remove(t)
            break
 
#Main Entity Class
class Entity(pygame.sprite.Sprite):
 
    def __init__(self):
        pygame.sprite.Sprite.__init__(self)
 
#The Player Class
class Player(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image_cache = image_cache
        self.pos_x = x
        self.pos_y = y
        self.in_shop = False
        self.image = get_image("data/images/Character.png", self.image_cache)
        self.image.convert()
        self.rect = Rect(self.pos_x, self.pos_y, 32, 32)
 
    def update(self, up, down, left, right, position_check,
               obsticles, trees, level_width, level_height):
        if up:
            self.pos_y = -8
        elif down:
            self.pos_y = 8
        elif left:
            self.pos_x = -8
        elif right:
            self.pos_x = 8
 
        if not (up or down):
            self.pos_y = 0
        if not (left or right):
            self.pos_x = 0
 
        #Moving the character
        self.rect.left += self.pos_x
        self.rect.top += self.pos_y
 
        #Collision Detection and animations
        self.Collision_Test(level_width, level_height, trees)
 
        if position_check:
            print "Player Pos: %s " % (self.rect)
 
    def Collision_Test(self, level_width, level_height, trees):
        if self.rect.top < 0 :
            self.pos_y = 0
            self.rect.top = 0
 
        if self.rect.bottom > level_height:
            self.pos_y = 0
            self.rect.bottom = level_height
 
        if self.rect.left < 0:
            self.pos_x = 0
            self.rect.left = 0
 
        if self.rect.right > level_width:
            self.pos_x = 0
            self.rect.right = level_width
 
        for t in trees:
            if pygame.sprite.collide_rect(self, t):
                if self.pos_x > 0:
                    self.rect.right = t.rect.left
                    self.pos_x = 0
                    self.pos_y = 0
                elif self.pos_x < 0:
                    self.rect.left = t.rect.right
                    self.pos_x = 0
                    self.pos_y = 0
                elif self.pos_y > 0:
                    self.rect.bottom = t.rect.top
                    self.pos_x = 0
                    self.pos_y = 0
                elif self.pos_y < 0:
                    self.rect.top = t.rect.bottom
                    self.pos_x = 0
                    self.pos_y = 0
 
                 
    def Walking_Animation(self, walking, up, down, left, right):
        walk = walking
        if down:
            if walk:
                walk = False
                self.image = get_image("data/images/Character_W.png", self.image_cache)
            elif not walk:
                walk = True
                self.image = get_image("data/images/Character.png", self.image_cache)
        elif up:
            if walk:
                walk = False
                self.image = get_image("data/images/Character_Back_W.png", self.image_cache)
            elif not walk:
                walk = True
                self.image = get_image("data/images/Character_Back.png", self.image_cache)
        elif left:
            if walk:
                walk = False
                self.image = get_image("data/images/Character_Left_W.png", self.image_cache)
            elif not walk:
                walk = True
                self.image = get_image("data/images/Character_Left.png", self.image_cache)
        elif right:
            if walk:
                walk = False
                self.image = get_image("data/images/Character_Right_W.png", self.image_cache)
            elif not walk:
                walk = True
                self.image = get_image("data/images/Character_Right.png", self.image_cache)
                                   
        return walk
 
    def get_pos(self):
        return (self.pos_x, self.pos_y)
 
#mouse Class
class Mouse(Entity):
 
    def __init__(self, pos):
        Entity.__init__(self)
        self.x = pos[0]
        self.y = pos[1]
        self.rect = Rect(pos[0], pos[1], 32, 32)
 
    def update(self, pos, check=False):
        self.x = pos[0]
        self.y = pos[1]
        self.rect.top = pos[1]
        self.rect.left = pos[0]
 
        if check:
            print "Mouse Pos: %s" %(self.rect)
            print self.x, self.y
 
    def get_rect(self):
        return (self.x, self.y)
 
#Grass Class
class Grass(Entity):
   
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.x = x
        self.y = y
        self.image = get_image("data/images/Grass.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
#Plain Grass
class Plain_Grass(Entity):
       
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.x = x
        self.y = y
        self.image = get_image("data/images/Grass_Plain.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
#Grass With Flower
class Grass_Flower(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.x = x
        self.y = y
        self.image = get_image("data/images/Grass_Flower.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
#Grass To Sand (Directly, no angles)
class Grass_To_SandD(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Grass_To_SandD.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
 
#Trees
class Tree(Entity):
 
    def __init__(self, x, y, image_cache):
        global rect, image
        Entity.__init__(self)
        self.image = get_image("data/images/Tree.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
#Paths
class Path(Entity):
 
    def __init__(self, x, y, image_cache, tree_ents):
        Entity.__init__(self)
        self.image = get_image("data/images/Path.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
#Sands
class Sand(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Sand.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
            return self.rect
 
#Sand With Dead Tree
class Sand_Dead(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Dead_Branch.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
 
#Sand To Water Direct (Shore Line)
class Sand_To_Water(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Sand_To_Water.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
 
#Water
class Water(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Water.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
 
class Dug_Out(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image = get_image("data/images/Dug_Out.png", image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 32, 32)
    def hit_test(self, x, y):
        return (self.rect.x <= x < self.rect.x+self.rect.width and
                self.rect.y <= y < self.rect.y+self.rect.height)
    def get_rect(self):
        return self.rect
 
 
#Start Menu New Game
class New_Game(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image_cache = image_cache
        self.image = get_image("data/images/New_Game.png", self.image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 200, 50)
 
    def update(self, mousepos):
        if self.rect.collidepoint(mousepos):
            self.image = get_image("data/images/New_Game_Hover.png", self.image_cache)
        else:
            self.image = get_image("data/images/New_Game.png", self.image_cache)
 
    def check_click(self, clicked, mousepos):
        if self.rect.collidepoint(mousepos):
            if clicked:
                self.image = get_image("data/images/New_Game_Hover.png", self.image_cache)
                start = True
            else:
                start = False
        else:
            start = False
        return start
 
#Start Menu Quit Button
class Quit_Game(Entity):
 
    def __init__(self, x, y, image_cache):
        Entity.__init__(self)
        self.image_cache = image_cache
        self.image = get_image("data/images/Quit.png", self.image_cache)
        self.image.convert()
        self.rect = Rect(x, y, 200, 50)
 
    def update(self, mousepos, clicked):
        if self.rect.collidepoint(mousepos):
            self.image = get_image("data/images/Quit_Hover.png", self.image_cache)
            if clicked:
                pygame.quit()
                sys.exit()
        else:
            self.image = get_image("data/images/Quit.png", self.image_cache)
           
#Screen shot functionality
def take_screen_shot(screen):
    time_taken = time.asctime(time.localtime(time.time()))
    time_taken = time_taken.replace(" ", "_")
    time_taken = time_taken.replace(":", ".")
    save_file = "screenshots/" + time_taken + ".png"
    pygame.image.save(screen, save_file)
    print "A screen shot has been taken and saved as: " + save_file
   
   
 
#This is a test to load images into a dictionary for faster loading
def get_image(key, cache):
    if not key in cache:
        cache[key] = pygame.image.load(key).convert_alpha()
    return cache[key]
 
def currentLevelChecker(area="generation"):
    return area
 
class Camera(object):
 
    def __init__(self, camera_func, width, height):
        self.camera_func = camera_func
        self.state = Rect(0, 0, width, height)
 
    def apply(self, target):
        return target.rect.move(self.state.topleft)
 
    def update(self, target):
            self.state = self.camera_func(self.state, target.rect)
 
"""
        KEY:
       Screen Size = 640x640
        G = Grass
        P = Plain Grass (less detail)
        F = Grass Flower (Includes A Flower...)
        Y = Grass -> Sand (Direct)
        L = Grass -> Sand (From Left)
        R = Grass -> Sand (From Right)
        T = Grass -> Sand (Tiny Grass)
        S = Sand
        Q = Sand -> Water (Direct)
        W = Water
        O = Stone Path
        H = House (Decoration)
        M = Armor Shop
        N = Weapon Shop
        B = Potion Shop
        C = Dungeon Entrance
        D = Sand (Dead)
"""
 
def Checker(area="generation"):
    if area == "testPlace":
        level = testPlace()
    elif area == "generation":
        level = tileMapGeneration()
 
    return level
 
 
def testPlace():
 
    #This is where all the testing happens...
   
    tilemap = [
            'TTTTTTTTTTTTTTTTTTTTTTTTTT',
            'TGFGGGGPPFPGGGGGGGGGGGGGGT',
            'TGGGGGGGFGPGGGGGGGGGGGGGGT',
            'TGGGGGGGGFPFFGFGGGGGGGGGGT',
            'OOOOOOOOOOOOOOOOOOOOOOOOOO',
            'OOOOOOOOOOOOOOOOOOOOOOOOOO',
            'GGFGGGGGGOOFGGGGGGGGGGGGGG',
            'FGFTGGGGTOOFGGGGGGGGGGGGGG',
            'TGGGGGGGGOOTGGGGFGPGGGGGGG',
            'GGGTFGGGGOOGGGGGGGTGGGGGGG',
            'GGGGGGGGGGGGGFGGGTGGGGGGGG',
            'YYYYYYYYYYYYYYYYYYYYYYYYYY',
            'SSSSSSSSSSSSSSSSSSSSSSSSSS',
            'SSSSSSSSSSSSSSSSSSSSSSSSSS',
            'SSSSSSSSSSSSSSSSSSSSSSSSSS',
            'QQQQQQQQQQQQQQQQQQQQQQQQQQ',
            'WWWWWWWWWWWWWWWWWWWWWWWWWW',
            'WWWWWWWWWWWWWWWWWWWWWWWWWW',
            'WWWWWWWWWWWWWWWWWWWWWWWWWW',
            'WWWWWWWWWWWWWWWWWWWWWWWWWW',
            'WWWWWWWWWWWWWWWWWWWWWWWWWW',
]
 
    return tilemap
 
 
def tileMapGeneration():
 
    tilemap = []
    levelString = ""
 
    biome = random.randint(1,3)
    if biome == 1:
        biome = "forest"
    if biome == 2:
        biome = "plains"
    if biome == 3:
        biome = "desert"
 
    waterAmount = random.randint(1,20)
 
    print biome
    while len(tilemap) != 100:
        structure = random.randint(1,10)
        if biome != "desert":
            if biome == "plains" and (structure == 1 or
                                      structure == 6 or
                                      structure == 7 or
                                      structure == 8 or
                                      structure == 9 or
                                      structure == 10):
                    levelString += "G"
            elif biome != "plains" and structure == 1:
                levelString += "G"
           
        if biome != "desert":
            if biome == "forest" and (structure == 2 or
                                      structure == 6 or
                                      structure == 7 or
                                      structure == 8 or
                                      structure == 9 or
                                      structure == 10):
                    levelString += "T"
            elif biome != "forest" and structure == 2:
                levelString += "T"
 
        if biome == "desert" and (structure == 3 or
                                   structure == 6 or
                                   structure == 7 or
                                   structure == 8 or
                                   structure == 9 or
                                   structure == 10):
            randomSand = random.randint(1,1000)
            if randomSand < 990:
                levelString += "S"
            elif randomSand == 991 and waterAmount > 0:
                levelString += "W"
                waterAmount -= 1
            elif randomSand > 991:
                levelString += "D"
        if biome != "desert":
            if structure == 4:
                levelString += "P"
        if biome != "desert":
            if structure == 5:
                levelString += "F"
           
        if len(levelString) == 100:
            tilemap.append(levelString)
            levelString = ""
 
    return tilemap
 
   
   
if __name__ == "__main__":
    main()
